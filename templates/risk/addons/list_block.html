 <div id="risks-container">
    {% for rsk in risks %}
    <div class="card mb-3 shadow-sm position-relative risk-item" 
         data-direct="{{ rsk.direction.id }}" 
         data-subject="{{ rsk.subject.id }}"
         data-risk-id="{{ rsk.id }}"
         data-risk-name="{{ rsk.risk|lower }}"
         data-negative-consequences="{{ rsk.negative_consequences|striptags|lower }}">
        <div class="card-body">
            <div class="risk-card-content">
                <div class="risk-id mb-2">
                    <span class="badge bg-secondary">ID: {{ rsk.id }}</span>
                </div>
                <h5 class="risk-name">{{ rsk.risk }}</h5>
                <div class="risk-negative-consequences">
                    <h6>Негативные последствия:</h6>
                    <p class="risk-negative-text">{{ rsk.negative_consequences|striptags|truncatechars:100 }}</p>
                </div>
                <a href="{{ rsk.get_absolute_url }}" class="stretched-link"> </a>
            </div>
        </div>
    </div>
    {% empty %}
    <p class="text-muted">Нет рисков.</p>
    {% endfor %}
</div>

<script>
document.addEventListener('DOMContentLoaded', function() {
    // Элементы DOM
    const risksContainer = document.getElementById('risks-container');
    const riskItems = document.querySelectorAll('.risk-item');
    const directionFilter = document.getElementById('direction-filter');
    const subjectFilter = document.getElementById('subject-filter');
    const searchInput = document.getElementById('risk-search');
    const resetButton = document.getElementById('reset-filters');

    /**
     * Функция для подсветки найденного текста
     */
    function highlightText(element, query, className = 'highlight') {
        if (!query || query.length < 2) {
            removeHighlight(element);
            return;
        }

        const walker = document.createTreeWalker(
            element,
            NodeFilter.SHOW_TEXT,
            null,
            false
        );

        const textNodes = [];
        let node;
        while (node = walker.nextNode()) {
            textNodes.push(node);
        }

        textNodes.forEach(textNode => {
            const text = textNode.textContent;
            const regex = new RegExp(`(${query})`, 'gi');

            if (regex.test(text)) {
                const highlightedText = text.replace(regex, `<mark class="${className}">$1</mark>`);
                const wrapper = document.createElement('span');
                wrapper.innerHTML = highlightedText;
                textNode.parentNode.replaceChild(wrapper, textNode);
            }
        });
    }

    /**
     * Функция для удаления подсветки
     */
    function removeHighlight(element) {
        const highlights = element.querySelectorAll('mark.highlight');
        highlights.forEach(mark => {
            const parent = mark.parentNode;
            parent.replaceChild(document.createTextNode(mark.textContent), mark);
            parent.normalize();
        });
    }

    /**
     * Поиск делаем частью общей фильтрации. Этот хелпер просто триггерит её.
     */
    function searchRisks() {
        filterRisks();
    }
    
    /**
     * Функция фильтрации рисков
     */
    function filterRisks() {
        const directionCheckboxes = document.querySelectorAll('.direction-checkbox');
        const subjectCheckboxes = document.querySelectorAll('.subject-checkbox');
        const query = searchInput ? searchInput.value.toLowerCase().trim() : '';
        
        const selectedDirections = Array.from(directionCheckboxes)
            .filter(cb => cb.checked)
            .map(cb => cb.value);
        
        const selectedSubjects = Array.from(subjectCheckboxes)
            .filter(cb => cb.checked)
            .map(cb => cb.value);

        let visibleCount = 0;
        
        riskItems.forEach(item => {
            const itemDirect = item.getAttribute('data-direct');
            const itemSubject = item.getAttribute('data-subject');
            const riskId = item.dataset.riskId || '';
            const riskName = item.dataset.riskName || '';
            const negativeConsequences = item.dataset.negativeConsequences || '';
            
            // Проверка соответствия фильтрам
            const directMatch = selectedDirections.length === 0 || selectedDirections.includes(itemDirect);
            const subjectMatch = selectedSubjects.length === 0 || selectedSubjects.includes(itemSubject);
            const searchMatch = !query || riskId.includes(query) || riskName.includes(query) || negativeConsequences.includes(query);

            const shouldShow = directMatch && subjectMatch && searchMatch;
            
            // Показываем/скрываем элемент
            item.style.display = shouldShow ? 'block' : 'none';
            // Подсветка текста
            removeHighlight(item);
            if (shouldShow && query.length >= 2) {
                const riskNameElement = item.querySelector('.risk-name');
                const riskNegativeElement = item.querySelector('.risk-negative-text');
                if (riskNameElement && riskName.includes(query)) {
                    highlightText(riskNameElement, query);
                }
                if (riskNegativeElement && negativeConsequences.includes(query)) {
                    highlightText(riskNegativeElement, query);
                }
            }
            
            if (shouldShow) {
                visibleCount++;
            }
        });
        
        // Показываем сообщение если нет результатов
        updateEmptyState();
    }

    /**
     * Глобальная функция для применения всех фильтров
     */
    window.applyAllFilters = function() {
        filterRisks();
    };

    /**
     * Глобальная функция для сброса всех фильтров
     */
    window.resetAllFilters = function() {
        const directionCheckboxes = document.querySelectorAll('.direction-checkbox');
        const subjectCheckboxes = document.querySelectorAll('.subject-checkbox');
        
        // Сбрасываем направления
        directionCheckboxes.forEach(cb => cb.checked = false);
        
        // Сбрасываем предметы
        subjectCheckboxes.forEach(cb => cb.checked = false);
        
        if (searchInput) searchInput.value = '';
        
        // Убираем всю подсветку
        riskItems.forEach(item => {
            removeHighlight(item);
        });
        
        filterRisks();
    };

    /**
     * Показывает/скрывает сообщение об отсутствии результатов
     */
    function updateEmptyState() {
        const visibleItems = Array.from(riskItems).filter(item => item.style.display !== 'none');
        let emptyMessage = risksContainer.querySelector('.empty-state-message');

        if (visibleItems.length === 0) {
            if (!emptyMessage) {
                emptyMessage = document.createElement('div');
                emptyMessage.className = 'empty-state-message text-center py-5';
                emptyMessage.innerHTML = `
                    <div class="text-muted">
                        <i class="bi bi-search" style="font-size: 3rem; opacity: 0.3;"></i>
                        <h5 class="mt-3">Риски не найдены</h5>
                        <p>Попробуйте изменить параметры поиска или фильтры</p>
                    </div>
                `;
                risksContainer.appendChild(emptyMessage);
            }
            emptyMessage.style.display = 'block';
        } else if (emptyMessage) {
            emptyMessage.style.display = 'none';
        }
    }
    
    // Обработчик поиска
    if (searchInput) {
        searchInput.addEventListener('input', searchRisks);
    }

    // Первичная фильтрация при загрузке страницы
    filterRisks();
});
</script>